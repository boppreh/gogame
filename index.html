<!DOCTYPE html>
<html>
	<head>
		<title>Go</title>
		<meta charset='utf-8'>
	</head>

	<body>
		<canvas id="go-board" width=700 height=700></canvas>

		<script>
"use strict";

let EMPTY = "empty";
let BLACK = "black";
let WHITE = "white";
let NOTHING = "nothing";

let SUICIDE = "suicide";
let KO = "ko";

function Renderer(size, canvas) {
	let stoneSizeRatio = 0.8 / 2;
	let context = canvas.getContext("2d");
	let padding = 10;
	let minSide = Math.min(canvas.width, canvas.height * (size / (size+1)) - padding);
	let cellSize = Math.floor((minSide - 2 * padding) / size);
	let territoryScale = 0.3;
	let scoringArea = padding + cellSize;

	let animations = [];

	let cachedBackgroundCanvas = document.createElement("canvas");
	cachedBackgroundCanvas.width = minSide;
	cachedBackgroundCanvas.height = minSide + scoringArea;
	let cachedBlackStoneCanvas = document.createElement("canvas");
	cachedBlackStoneCanvas.width = cellSize;
	cachedBlackStoneCanvas.height = cellSize;
	let cachedWhiteStoneCanvas = document.createElement("canvas");
	cachedWhiteStoneCanvas.width = cellSize;
	cachedWhiteStoneCanvas.height = cellSize;
	let cachedWhiteTerritoryCanvas = document.createElement("canvas");
	cachedWhiteTerritoryCanvas.width = cellSize;
	cachedWhiteTerritoryCanvas.height = cellSize;
	let cachedBlackTerritoryCanvas = document.createElement("canvas");
	cachedBlackTerritoryCanvas.width = cellSize;
	cachedBlackTerritoryCanvas.height = cellSize;

	let stonesCanvas = document.createElement("canvas");
	stonesCanvas.width = minSide;
	stonesCanvas.height = minSide + scoringArea;

	let topRight = translateRowCol({row: 0, col: size-1}, true);
	let gridStart = topRight.y;
	let gridEnd = topRight.x;
	let lineWidth = Math.max(2, Math.floor(4 * cellSize / 100));

	let stonesPos = {};
	function getStonePos(stone) {
		let id = [stone.row, stone.col, stone.type];
		if (!stonesPos[id]) {
			// Caching is necessary because translateRowCol has random components.
			stonesPos[id] = translateRowCol(stone);
		}
		return stonesPos[id];
	}

	function drawBoardBackground(context) {
		context.save();
		// Fix blurry lines: https://stackoverflow.com/a/8696641/252218
		context.translate(0.5, 0.5);

		context.fillStyle = "#E2C58B"
		context.fillRect(0, 0, minSide, minSide + scoringArea);

		context.strokeStyle = "rgba(180, 139, 89, 0.4)";
		context.lineWidth = 2;
		context.shadowColor = "rgba(180, 139, 89, 0.9)";
		context.shadowBlur = 3;
		context.shadowOffsetX = -3;
		context.shadowOffsetY = 0;
		context.beginPath();
		let boardBackgroundStreaks = [];
		for (let x = 0; x < minSide; ) {
			x += Math.floor(Math.random() * minSide / 10);
			context.moveTo(x, 0);
			context.lineTo(x + Math.floor((2 * Math.random() - 1) * 1 * minSide / 30), minSide + scoringArea);
		}
		context.stroke();

		drawBoardLines(context);

		let gradient = context.createLinearGradient(0, 0, minSide, 0);
		gradient.addColorStop(0.00, "rgba(0, 0, 0, 0.05)");
		gradient.addColorStop(0.25, "rgba(255, 255, 255, 0.02)");
		gradient.addColorStop(0.50, "rgba(0, 0, 0, 0.09)");
		gradient.addColorStop(0.70, "rgba(255, 255, 255, 0.01)");
		gradient.addColorStop(1.00, "rgba(0, 0, 0, 0.1)");
		context.fillStyle = gradient;
		context.fillRect(0, 0, minSide, minSide + scoringArea);

		drawOneStone(context, BLACK, translateRowCol({row: size, col: 1}, true), 1, false);
		drawOneStone(context, BLACK, translateRowCol({row: size+0.3, col: 1-0.3}, true), 1, true);
		drawOneStone(context, WHITE, translateRowCol({row: size, col: size-2}, true), 1, false);
		drawOneStone(context, WHITE, translateRowCol({row: size+0.3, col: size-2-0.3}, true), 1, true);

		context.restore();
	}
	function drawBoardLines(context) {
		context.save();
		context.globalAlpha = 1;
		context.lineWidth = 1;
		context.lineJoin = "square";
		context.strokeStyle = "#FFFFFF";
		context.translate(lineWidth/2, lineWidth/2);
		context.beginPath();
		context.moveTo(gridEnd, gridStart);
		context.lineTo(gridStart, gridStart);
		context.lineTo(gridStart, gridEnd);
		context.lineTo(gridEnd, gridEnd);
		context.lineTo(gridEnd, gridStart);
		context.closePath();

		for (let i = 1; i < size-1; i++) {
			context.moveTo(gridStart, gridStart + i * cellSize);
			context.lineTo(gridEnd, gridStart + i * cellSize);
			context.moveTo(gridStart + i * cellSize, gridStart);
			context.lineTo(gridStart + i * cellSize, gridEnd);
		}
		context.stroke();
		context.restore();

		context.save();
		context.globalAlpha = 0.8;
		context.lineWidth = lineWidth;
		context.lineJoin = "square";
		context.strokeStyle = "#333333";
		context.shadowColor = "rgba(10, 10, 10, 0.3)";
		context.shadowBlur = 1;
		context.shadowOffsetX = 1;
		context.shadowOffsetY = 1;

		context.beginPath();
		context.moveTo(gridEnd, gridStart);
		context.lineTo(gridStart, gridStart);
		context.lineTo(gridStart, gridEnd);
		context.lineTo(gridEnd, gridEnd);
		context.lineTo(gridEnd, gridStart);
		context.closePath();

		for (let i = 1; i < size-1; i++) {
			context.moveTo(gridStart, gridStart + i * cellSize);
			context.lineTo(gridEnd, gridStart + i * cellSize);
			context.moveTo(gridStart + i * cellSize, gridStart);
			context.lineTo(gridStart + i * cellSize, gridEnd);
		}
		context.stroke();
		context.restore();
	}
	function drawRawStone(context, type, scale) {
		scale = scale || 1;
		context.save();
		context.translate(cellSize / 2, cellSize / 2);
		context.scale(stoneSizeRatio * scale, stoneSizeRatio * scale);

		context.lineWidth = 1;
		context.shadowColor = "rgba(30, 30, 30, 0.5)";
		context.shadowBlur = 5 * cellSize / 100;
		context.shadowOffsetX = 4 * cellSize / 100;
		context.shadowOffsetY = 4 * cellSize / 100;

		let gradient = context.createRadialGradient(0, 0, cellSize, -cellSize * 0.1, -cellSize * 0.1, cellSize * 0.8);
		if (type == WHITE) {
			context.strokeStyle = "#DDDDDD";
			gradient.addColorStop(0, "#B0B0B0");
			gradient.addColorStop(1, "#DDDDDD");
		} else if (type == BLACK) {
			context.strokeStyle = "#222222";
			gradient.addColorStop(0, "#222222");
			gradient.addColorStop(1, "#333333");
		}
		context.fillStyle = gradient;

		context.beginPath();
		context.arc(0, 0, cellSize, 0, Math.PI*2);
		context.stroke();
		context.fill();

		context.restore();
	}
	function drawOneStone(context, type, canvasPos, transparency, asTerritory) {
		let cachedCanvas = type == WHITE ? (asTerritory ? cachedWhiteTerritoryCanvas : cachedWhiteStoneCanvas) : (asTerritory ? cachedBlackTerritoryCanvas : cachedBlackStoneCanvas);
		context.save()
		context.globalAlpha = transparency || 1;
		context.drawImage(cachedCanvas, canvasPos.x - cachedCanvas.width / 2, canvasPos.y - cachedCanvas.height / 2);
		context.restore();
	}
	function drawBoardStones(context, board) {
		context.save();

		context.font = "bold " + Math.round(cellSize / 3) + "px Arial";
		context.textAlign = "center";
		context.textBaseline = "middle";

		function connectTo(type, stonePos, neighborPos) {
			context.beginPath();
			context.strokeStyle = type == BLACK ? "#000000" : "#FFFFFF";
			context.moveTo(stonePos.x, stonePos.y);
			context.lineTo(neighborPos.x, neighborPos.y)
			context.stroke();
		}

		context.save();
		context.globalAlpha = 0.5;
		context.lineWidth = Math.max(15, cellSize * 0.15);
		context.shadowBlur = 1;
		context.shadowOffsetX = 1;
		context.shadowOffsetY = 1;
		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
				let stone = board[row][col]
				if (stone.type == EMPTY) continue;
				let stonePos = translateRowCol(stone, true)

				if (col > 0 && stone.type == board[row][col-1].type) {
					let neighborPos = translateRowCol(board[row][col-1], true);
					connectTo(stone.type, stonePos, neighborPos);
				}
				if (row > 0 && stone.type == board[row-1][col].type) {
					let neighborPos = translateRowCol(board[row-1][col], true);
					connectTo(stone.type, stonePos, neighborPos);
				}

			}
		}
		context.restore();

		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
				let stone = board[row][col];
				let pos;
				let type;
				if (stone.group.territory === EMPTY) continue;

				if (stone.type == EMPTY) {
					pos = translateRowCol(stone, true);
					drawOneStone(context, stone.group.territory, pos, 1, true);
				} else {
					pos = getStonePos(stone);
					drawOneStone(context, stone.type, pos);
					if (stone.group.nLiberties == 1)
						context.fillStyle = stone.type == BLACK ? "#BB4444" : "#A64545";
					else if (stone.group.nEyes >= 2)
						context.fillStyle = stone.type == BLACK ? "#D4AF37" : "#DAA520";
					else
						context.fillStyle = stone.type == BLACK ? "#BBBBBB" : "#444444";
					context.fillText(stone.group.nLiberties, pos.x, pos.y);
				}
			}
		}
		context.restore();
	}
	function translateRowCol(boardPos, deterministic) {
		let wiggleX = (deterministic ? 0 : 2 * Math.random() - 1) * cellSize * 0.05;
		let wiggleY = (deterministic ? 0 : 2 * Math.random() - 1) * cellSize * 0.05;
		let x = padding + cellSize/2 + boardPos.col * cellSize + wiggleX;
		let y = padding + cellSize/2 + boardPos.row * cellSize + wiggleY;
		return {x: x, y: y};
	}

	drawRawStone(cachedWhiteStoneCanvas.getContext("2d"), WHITE, 1);
	drawRawStone(cachedBlackStoneCanvas.getContext("2d"), BLACK, 1);
	drawRawStone(cachedWhiteTerritoryCanvas.getContext("2d"), WHITE, territoryScale);
	drawRawStone(cachedBlackTerritoryCanvas.getContext("2d"), BLACK, territoryScale);
	drawBoardBackground(cachedBackgroundCanvas.getContext("2d"));

	function drawBoard() {
		// Erase contents and reset canvas.
		canvas.width = canvas.width;
		context.drawImage(cachedBackgroundCanvas, 0, 0);
		context.drawImage(stonesCanvas, 0, 0);
	}

	function update() {
		drawBoard();
		for (let i = animations.length - 1; i >= 0; i--) {
			context.save();
			let shouldContinue = animations[i]();
			context.restore();
			if (!shouldContinue) {
				animations.splice(i, 1);
			}
		}
	}

	function drawScore(context, scoreByType) {
		context.save();
		context.font = "bold " + Math.round(cellSize / 3) + "px Arial";
		context.textAlign = "center";
		context.textBaseline = "middle";
		context.shadowBlur = 1;
		context.shadowOffsetX = 1;
		context.shadowOffsetY = 1;
		context.fillStyle = "#BBBBBB";
		let blackPos = translateRowCol({row: size, col: 1}, true)
		context.fillText(scoreByType[BLACK], blackPos.x, blackPos.y);
		context.fillStyle = "#444444";
		let whitePos = translateRowCol({row: size, col: size - 2}, true)
		context.fillText(scoreByType[WHITE], whitePos.x, whitePos.y);
		context.restore();
	}

	function animatePlay(type, boardPos, state, callback) {
		let board = state.board;
		let removed = state.recentlyRemoved;
		let step = 0;
		let direction = type == WHITE ? -1 : 1;
		animations.push(function() {
			context.globalAlpha = step;
			let pos = getStonePos(boardPos);
			context.translate(pos.x, pos.y + (1 - step) * cellSize * direction * 2);
			context.scale(1.5 - step/2, 1.5 - step/2);
			drawOneStone(context, type, {x: 0, y: 0});
			step += 0.1;
			if (step <= 1) {
				return true;
			} else {
				for (let removedStone of removed) {
					animateRemoval(removedStone);
				}
				stonesCanvas.width = stonesCanvas.width;
				drawBoardStones(stonesCanvas.getContext("2d"), board);
				drawScore(stonesCanvas.getContext("2d"), state.scoreByType);
				callback && callback();
				return false;
			}
		});
	}

	function animateRemoval(stone) {
		let step = 0;
		animations.push(function() {
			step += 0.1;
			if (step > 1) {
				return false;
			}
			context.globalAlpha = 1 - step;
			let pos = getStonePos(stone);
			context.translate(pos.x, pos.y);
			context.scale(1 + step/3, 1 + step/3);
			drawOneStone(context, stone.previously, {x: 0, y: 0});
			return true;
		});
	}

	function screenToBoard(x, y) {
		return {row: Math.round((y - canvas.offsetTop - padding - cellSize/2) / cellSize),
				col: Math.round((x - canvas.offsetLeft - padding - cellSize/2) / cellSize)}
	}

	return {
		screenToBoard: screenToBoard,
		update: update,
		animatePlay: animatePlay,
		drawGhost: function(type, boardPos) { let pos = translateRowCol(boardPos, true); drawOneStone(context, type, pos, 0.3); },
	}
}

function State(baseBoard, size, turn, history) {
	history = history || []

	let board = [];
	for (let row = 0; row < size; row++) {
		board.push([]);
		for (let col = 0; col < size; col++) {
			board[row][col] = {type: baseBoard ? baseBoard[row][col].type : EMPTY, row: row, col: col, group: null};
		}
	}
	if (baseBoard) {
		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
			}
		}
	}

	let recentlyRemoved = []
	let scoreByType = {white: 0, black: 0};
	let groups = [];

	function playAt(pos, tentative) {
		let clone = State(board, size, turn === BLACK ? WHITE : BLACK, history);

		let stone = clone.getStoneAtPos(pos);
		if (stone.type != EMPTY) {
			return null;
		}

		stone.type = turn;
		clone.sweepBoard();
		let suicide = clone.recentlyRemoved.indexOf(stone) != -1;
		if (suicide) {
			return SUICIDE;
		}
		let string = clone.asString();
		if (history.indexOf(string) >= 0) {
			return KO;
		}
		if (!tentative)
			history.push(string);

		return clone
	}

	function asString() {
		let stoneTypes = [];
		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
				stoneTypes.push(board[row][col].type);
			}
		}
		return stoneTypes.join(" ")
	}

	function sweepBoard() {
		calculateGroups();
		removeLockedGroups(turn);

		if (recentlyRemoved.length) calculateGroups();
		removeLockedGroups(turn == WHITE ? BLACK : WHITE);

		if (recentlyRemoved.length) calculateGroups();
	}

	function calculateGroups() {
		scoreByType[WHITE] = 0;
		scoreByType[BLACK] = 0;
		groups.length = 0;
		let visited = {};
		function followGroup(stone, group, baseType) {
			let pos = [stone.row, stone.col];
			if (stone.type === baseType) {
				if (visited[pos]) return;
				visited[pos] = true;
				stone.group = group;
				stone.group.members.push(stone);
				followGroup(getStone(pos[0], pos[1]+1), group, baseType);
				followGroup(getStone(pos[0], pos[1]-1), group, baseType);
				followGroup(getStone(pos[0]+1, pos[1]), group, baseType);
				followGroup(getStone(pos[0]-1, pos[1]), group, baseType);
			} else {
				group.neighborsByColors[stone.type][pos] = stone;
			}
		}
		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
				let pos = [row, col];
				if (visited[pos]) continue;
				let stone = getStone(row, col);
				stone.group = {type: stone.type, members: [], nEyes: 0, nLiberties: 0, neighborsByColors: {white: {}, black: {}, empty: {}, nothing: {}}};
				groups.push(stone.group);
				followGroup(stone, stone.group, stone.type);
			}
		}
		for (let group of groups) {
			if (group.type !== EMPTY) {
				group.territory = group.type;
			} else {
				let nWhites = Object.values(group.neighborsByColors[WHITE]).length;
				let nBlacks = Object.values(group.neighborsByColors[BLACK]).length;
				if (nWhites === 0 && nBlacks)
					group.territory = BLACK;
				else if (nWhites && nBlacks === 0)
					group.territory = WHITE;
				else
					group.territory = EMPTY;
			}
			scoreByType[group.territory] += group.members.length;
		}
		for (let group of groups) {
			let type = group.members[0].type;
			group.nLiberties = Object.keys(group.neighborsByColors[EMPTY]).length;
			group.nEyes = Object.values(group.neighborsByColors[EMPTY]).filter(function(emptyStone) { return emptyStone.group.members.length === 1 && emptyStone.group.territory == type; }).length;
		}
	}

	function removeLockedGroups(type) {
		for (let row = 0; row < size; row++) {
			for (let col = 0; col < size; col++) {
				let stone = getStone(row, col);
				if (stone.type === type && stone.group.nLiberties === 0) {
					stone.previously = stone.type;
					stone.type = EMPTY;
					recentlyRemoved.push(stone);
				}
			}
		}
	}

	function getStone(row, col) {
		if (row < 0 || row >= size || col < 0 || col >= size) {
			return {type: NOTHING};
		}
		return board[row][col];
	}

	return {
		groups: groups,
		scoreByType: scoreByType,
		asString: asString,
		board: board,
		playAt: playAt,
		pass: function() { let passedState = State(board, size, turn === BLACK ? WHITE : BLACK, history); passedState.sweepBoard(); return passedState; },
		turn: turn,
		sweepBoard: sweepBoard,
		recentlyRemoved: recentlyRemoved,
		getStoneAtPos: function(pos) { return getStone(pos.row, pos.col) },
		getTurn: function() { return turn; },
	}
}

let size = 5;
let canvas = document.getElementById("go-board");
canvas.height = document.body.clientHeight;
canvas.width = document.body.clientWidth;
let state = State(null, size, BLACK);
let renderer = Renderer(size, canvas);
let hovering = {row: -1, col: -1};

function botPlay() {
	let emptyPos = [];
	for (let row = 0; row < size; row++) {
		for (let col = 0; col < size; col++) {
			let pos = {row: row, col: col};
			if (state.getStoneAtPos(pos).type === EMPTY) {
				let tentativeState = state.playAt(pos, true);
				if (tentativeState && tentativeState != SUICIDE && tentativeState != KO) {
					emptyPos.push([pos, tentativeState]);
				}
			}
		}
	}
	emptyPos.push([null, state.pass()]) // To represent passing.
	emptyPos.sort(function(playA, playB) {
		let stateA = playA[1];
		let killedA = stateA.recentlyRemoved.length;
		let atariA = stateA.groups.filter(g => g.nLiberties === 1 && g.type === WHITE).length;
		let scoreA = stateA.scoreByType[WHITE];

		let stateB = playB[1];
		let killedB = stateB.recentlyRemoved.length;
		let atariB = stateB.groups.filter(g => g.nLiberties === 1 && g.type === WHITE).length;
		let scoreB = stateA.scoreByType[WHITE];

		if (playA[0] === null || playB[0] === null) {
			console.log('Evaluation:')
			console.log(playA, playB);
			console.log(killedA, killedB);
			console.log(atariA, atariB);
			console.log(scoreA, scoreB);
		}

		if (killedA !== killedB) return killedA - killedB;
		if (atariA !== atariB) return -(atariA - atariB);
		if (scoreA !== scoreB) return scoreA - scoreB;
		if (playB[0] === null) return 1;
		if (playA[0] === null) return -1;
		return Math.random() * 2 - 1;
	});
	console.log(emptyPos);
	let posPair = emptyPos.pop();
	let pos = posPair[0];
	if (pos === null) {
		alert("The bot passes.");
		state = state.pass();
	} else {
		let newState = state.playAt(pos);
		renderer.animatePlay(WHITE, pos, newState);
		state = newState;
	}	
}

canvas.onclick = function(event) {
	if (state.turn === WHITE) return;
	let pos = renderer.screenToBoard(event.pageX, event.pageY);
	let newState = state.playAt(pos);
	if (newState === SUICIDE) {
		alert("Cannot move into a space that will kill your own stone.");
	} else if (newState === KO) {
		alert("Forbid by KO rule: one may not play in such a way as to recreate the board position following one's previous move.");
	} else if (newState) {
		renderer.animatePlay(BLACK, pos, newState, function() {
			state = newState;
			setTimeout(botPlay, 700 + Math.random()*200)
		});
	}
};
canvas.onmousemove = function(event) {
	let pos = renderer.screenToBoard(event.pageX, event.pageY);
	if (hovering.row != pos.row || hovering.col != pos.col) {
		renderer.update();
		hovering = pos;
	}
};

function update() {
	renderer.update();
	let hoveringType = state.getStoneAtPos(hovering).type;
	if (hoveringType == EMPTY) {
		renderer.drawGhost(state.turn, hovering);
	}
	window.requestAnimationFrame(update);
}
window.requestAnimationFrame(update);

		</script>

		<button onclick="state = state.pass(); setTimeout(botPlay, 400);">Pass</button>
		<button onclick="alert(state.scoreByType[BLACK] > state.scoreByType[WHITE] ? 'Congratulations, you won!' : 'The bot wins. Try again.'); window.location.reload(false);">End game</button>
	</body>
</html>
